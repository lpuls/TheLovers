# Code: The Lovers

Unity实现的多人太空战争游戏

## 多人方案

游戏支持最多两人局域网同步

### 网络

具体网络不详谈，大体就是用socket互传数据。

### 同步

    同步使用镜像同步，但并不是一帧就把所有的数据同步给各端，而是会将变化的结果打进帧包进行同步。

    举例说明，如果本帧有新的单位生成或着单位移除，该单位的增删就会进入帧包。同样的，单位的属性，例如位置，状态也会根据情况进入帧包。这样做的好处是减少帧包的大小；因为客户端使用的时根据状态变化来进行模拟或着触发事件的，有些没变化的数据对客户端来说是没有意义的，所以全打进去就没有必要。

    客户端模拟就如上说所，是通过前后状态对比的；注意，这里是前后状态对比而不是前后帧进行对比。以位置更新为例，如果我十帧前的位置是A，这十帧没有变化，那客户端就不会进行任何的位置变化（事实上是有一直在插值的，只是位置没有变化所以结果不变）。但现在有位置变化了，所以客户端需要对该单位以十帧前的位置与现的位置进行插值，此时客户端的位置才有实际的变化。

    而一些状态上的事件，例如死亡则去尝试获取帧包中是否有该单位的死亡状态，如果有的话说明他从之前的状态变化到了死亡，此时根据状态去播放死亡动画及相关特效就行了。

    而要完成以上这些内容，就需要对有同步必要的单位进行管理。游戏中使用NetSyncComponent来标记所有需要网络同步的单位，每个单位在生成时会得到唯一的ID，打帧包时及客户端获取帧包数据时都是通过该ID来进行操作。而客户端和服务端则通过FrameDataManager来进行管理；客户端与服务端操作不同，因此具体下去需要ClientFrameDataManager及ServerFrameDataManager两个管理器。

    BaseFrameDataManager是所有的FrameDataManager的基类，他除了提供一些基础数据之后最重要的是接供了ServerTick的操作；该操作用于将所有实现了ServerTicker接口的单位进么记录并按逻辑帧时间更新。这么做的原因在于，服务端的组件很多是需要固定帧来执行以保证，而客户端则需要以相同的方式运行一些逻辑来保证預測的结果。

    ServerFrameDataManager记录所有的NetSyncComponent及提供生成带NetSyncComponent的GameObject接口；World会调用ServerFrameDataManager的Update接口，该接口按指定的帧率来执行逻辑。执行的逻辑包括所有的ServerTicker的实例的执行；移除上一帧结束时死亡的逻辑对像；打包所有的需要的数据进帧包；将帧包发送给客户端。

    ClientFrameDataManager则需要分析服务端发下来的帧包，然后根据逻辑帧时长更新帧包；更新的同时也会调用ServerTicker的逻辑执行，以确定如預測相关的逻辑能正常。

    这当中有一个特殊的地方在于房主的逻辑，房主会同时拥有ServerFrameDataManager和ClientFrameDataManager，因为他既是客户端也是服务端。而他本身就在服务端上，所以他不会通过Socket进行网络同步，而是ServerFrameDataManager在完成帧包之后通过回调设置给ClientFrameDataManager。


### 預測

    游戏中为了消除网络延迟对手感的影响，需要在本地客户端进行預測，等收到服务端帧包之后再对預測结果进行对比；如果发生错误的话则所要以服务端数据为准，然后重新模拟记录在案的操作。

    客户端要預測的时候将操作结果，操作及当前操作时的客户端帧号记录下来并将操作和帧号发送给服务端。服务端收到该内容后会将所有的操作及客户端帧号进录到列表中；之所以要记录在列表中的原因在于可能存在网络延迟在一个逻辑帧内收到多个客户端操作帧，不记录到列表就会导致客户的操作丢失引起不預測错误；当一个逻辑帧到来之后，服务端由不断取出客户端操作并进行模拟直到将所有的客户端操作都模拟完成，再将最后一个操作的结果及帧号发回给客户端。

    客户端收到操作之后，取出并移除最早的預測结果，然后将服务端的預測帧号与记录在案的預測结果进行对比；对比时会出现以下三种情况：
    1. 服务端預測帧号与客户端預測帧号相同
        该情况下说明服务端这次只模拟了一帧，此时对比记录的结果和服务端的结果。如果结果不同，则说明預測失败，以当前服务端结果为准对后续的所有預測记录进行新的模拟；如果结果相同，则表示没有问题。

    2. 服务端預測帧号比客户端預測帧号大
        说明服务端本帧内执行了多个操作，些时模拟需要不断地将结果取出直到出现第一种情况。

    3. 服务端預測帧号比客户端預測帧号小
        说明出问题了，但是暂时不会影响，所以不管

### 组件

    根据客户端与客户端不同，有一些重要组件需要说明：

    NetSyncComponent是各端都有的，通过其中的NetID来进行关联。由一不同的时，在服务端的的所有网络单位都是Authority；而在客户端，如果是玩家操作的角色则为AutonomousProxy，其它单位都为SimulatedProxy。

    ServerPlayerController则为服务端单位独有的，该组件用于接收客户端发送的操作并调用移动组件，技能组件等功能性组件进行逻逻行为。

    ClientPlayerController则为客户端的AutonomousProxy单位独有，该组件用于记录預測的结果，发送操作给服务端及預測。

    SimulateComponent和PlayEffectComponent则为客户端独的，无论是AutonomousProxy还是SimulatedProxy都有这两个组件。前者用于根据服务端的数据对位置和朝向进行插值模拟；后则都根据状态播放动画，特效及声音相关的表现操作。

    理论上MovementComponent及AbilityComponent组件应该只有服务端有，但客户端需要模拟，所以客户端的单位也会添加上。


## 核心玩法